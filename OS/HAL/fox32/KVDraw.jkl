//
// Implements basic kernel video support.
// Used primarily by CoVideoConsole.
//

#INCLUDE "<ll>/Rtl.hjk"
#INCLUDE "../../OSLoader/Headers/Loader.hjk"

#INCLUDE "<inc>/HALConsole.hjk"
#INCLUDE "<inc>/HALCPU.hjk"
#INCLUDE "<inc>/HALMap.hjk"
#INCLUDE "<inc>/HALResource.hjk"
#INCLUDE "<inc>/HALCrash.hjk"

PUBLIC HALfox32IndexPalette : ULONG[] = {
    0xff000000,
    0xff220022,
    0xff440000,
    0xff660022,
    0xff880000,
    0xffaa0022,
    0xffcc0000,
    0xffee0022,
    0xff000044,
    0xff220066,
    0xff440044,
    0xff660066,
    0xff880044,
    0xffaa0066,
    0xffcc0044,
    0xffee0066,
    0xff000088,
    0xff2200aa,
    0xff440088,
    0xff6600aa,
    0xff880088,
    0xffaa00aa,
    0xffcc0088,
    0xffee00aa,
    0xff0000cc,
    0xff2200ee,
    0xff4400cc,
    0xff6600ee,
    0xff8800cc,
    0xffaa00ee,
    0xffcc00cc,
    0xffee00ee,
    0xff002200,
    0xff222222,
    0xff442200,
    0xff662222,
    0xff882200,
    0xffaa2222,
    0xffcc2200,
    0xffee2222,
    0xff002244,
    0xff222266,
    0xff442244,
    0xff662266,
    0xff882244,
    0xffaa2266,
    0xffcc2244,
    0xffee2266,
    0xff002288,
    0xff2222aa,
    0xff442288,
    0xff6622aa,
    0xff882288,
    0xffaa22aa,
    0xffcc2288,
    0xffee22aa,
    0xff0022cc,
    0xff2222ee,
    0xff4422cc,
    0xff6622ee,
    0xff8822cc,
    0xffaa22ee,
    0xffcc22cc,
    0xffee22ee,
    0xff004400,
    0xff224422,
    0xff444400,
    0xff664422,
    0xff884400,
    0xffaa4422,
    0xffcc4400,
    0xffee4422,
    0xff004444,
    0xff224466,
    0xff444444,
    0xff664466,
    0xff884444,
    0xffaa4466,
    0xffcc4444,
    0xffee4466,
    0xff004488,
    0xff2244aa,
    0xff444488,
    0xff6644aa,
    0xff884488,
    0xffaa44aa,
    0xffcc4488,
    0xffee44aa,
    0xff0044cc,
    0xff2244ee,
    0xff4444cc,
    0xff6644ee,
    0xff8844cc,
    0xffaa44ee,
    0xffcc44cc,
    0xffee44ee,
    0xff006600,
    0xff226622,
    0xff446600,
    0xff666622,
    0xff886600,
    0xffaa6622,
    0xffcc6600,
    0xffee6622,
    0xff006644,
    0xff226666,
    0xff446644,
    0xff666666,
    0xff886644,
    0xffaa6666,
    0xffcc6644,
    0xffee6666,
    0xff006688,
    0xff2266aa,
    0xff446688,
    0xff6666aa,
    0xff886688,
    0xffaa66aa,
    0xffcc6688,
    0xffee66aa,
    0xff0066cc,
    0xff2266ee,
    0xff4466cc,
    0xff6666ee,
    0xff8866cc,
    0xffaa66ee,
    0xffcc66cc,
    0xffee66ee,
    0xff008800,
    0xff228822,
    0xff448800,
    0xff668822,
    0xff888800,
    0xffaa8822,
    0xffcc8800,
    0xffee8822,
    0xff008844,
    0xff228866,
    0xff448844,
    0xff668866,
    0xff888844,
    0xffaa8866,
    0xffcc8844,
    0xffee8866,
    0xff008888,
    0xff2288aa,
    0xff448888,
    0xff6688aa,
    0xff888888,
    0xffaa88aa,
    0xffcc8888,
    0xffee88aa,
    0xff0088cc,
    0xff2288ee,
    0xff4488cc,
    0xff6688ee,
    0xff8888cc,
    0xffaa88ee,
    0xffcc88cc,
    0xffee88ee,
    0xff00aa00,
    0xff22aa22,
    0xff44aa00,
    0xff66aa22,
    0xff88aa00,
    0xffaaaa22,
    0xffccaa00,
    0xffeeaa22,
    0xff00aa44,
    0xff22aa66,
    0xff44aa44,
    0xff66aa66,
    0xff88aa44,
    0xffaaaa66,
    0xffccaa44,
    0xffeeaa66,
    0xff00aa88,
    0xff22aaaa,
    0xff44aa88,
    0xff66aaaa,
    0xff88aa88,
    0xffaaaaaa,
    0xffccaa88,
    0xffeeaaaa,
    0xff00aacc,
    0xff22aaee,
    0xff44aacc,
    0xff66aaee,
    0xff88aacc,
    0xffaaaaee,
    0xffccaacc,
    0xffeeaaee,
    0xff00cc00,
    0xff22cc22,
    0xff44cc00,
    0xff66cc22,
    0xff88cc00,
    0xffaacc22,
    0xffcccc00,
    0xffeecc22,
    0xff00cc44,
    0xff22cc66,
    0xff44cc44,
    0xff66cc66,
    0xff88cc44,
    0xffaacc66,
    0xffcccc44,
    0xffeecc66,
    0xff00cc88,
    0xff22ccaa,
    0xff44cc88,
    0xff66ccaa,
    0xff88cc88,
    0xffaaccaa,
    0xffcccc88,
    0xffeeccaa,
    0xff00cccc,
    0xff22ccee,
    0xff44cccc,
    0xff66ccee,
    0xff88cccc,
    0xffaaccee,
    0xffcccccc,
    0xffeeccee,
    0xff00ee00,
    0xff22ee22,
    0xff44ee00,
    0xff66ee22,
    0xff88ee00,
    0xffaaee22,
    0xffccee00,
    0xffeeee22,
    0xff00ee44,
    0xff22ee66,
    0xff44ee44,
    0xff66ee66,
    0xff88ee44,
    0xffaaee66,
    0xffccee44,
    0xffeeee66,
    0xff00ee88,
    0xff22eeaa,
    0xff44ee88,
    0xff66eeaa,
    0xff88ee88,
    0xffaaeeaa,
    0xffccee88,
    0xffeeeeaa,
    0xff00eecc,
    0xff22eeee,
    0xff44eecc,
    0xff66eeee,
    0xff88eecc,
    0xffaaeeee,
    0xffcceecc,
    0xfffffffe,
}

EXTERN HALLoaderInfo : ^BlInfoRecord

FBAddr : ^ULONG
FBSize : ULONG
FBModulo : ULONG

#SECTION "INITtext"
FN KVInit ()

    FBAddr = HALLoaderInfo^.BootFbBase
    FBSize = HALConsoleWidthPix * HALConsoleHeightPix * 4
    FBModulo = (HALConsoleWidthPix - HALConsoleFontWidth) * 4
END

FN KVQuery (
    OUT w : UWORD,
    OUT h : UWORD,
) : UWORD
    
    w = HALConsoleWidthPix
    h = HALConsoleHeightPix

    RETURN 0
END

FN KVFontGet (
    IN name : ^UBYTE,
    OUT font : ^HCFHeader,
) : UWORD

    rsrc := HALResourceByName ( name )

    IF NOT rsrc THEN
        RETURN -1
    END

    font = rsrc^.Data

    IF font^.Magic != HCF_MAGIC THEN
        RETURN -1
    END

    HALResourceWire ( rsrc )

    RETURN 0
END

FN KVFontQuery (
    IN font : ^HCFHeader,
    OUT width : UWORD,
    OUT height : UWORD,
)

    width = font^.Width
    height = font^.Height
END

FN KVI8ToNative (
    IN i8 : UWORD,
) : UWORD

    RETURN HALfox32IndexPalette[i8]
END

FN KVClearScreen (
    IN nativecolor : UWORD,
)

    RtlFillMemoryWithUlong (
        FBAddr, // ptr
        FBSize, // sz
        nativecolor, // ulong
    )
END

FN KVDrawFilledRectangle (
    IN nativecolor : UWORD,
    IN x : UWORD,
    IN y : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    row := 0
    gw := HALConsoleWidthPix

    fb := FBAddr

    ptr := fb + (y * gw * 4 + x * 4)

    mod := gw * 4

    rowsz := w * 4

    WHILE row < h DO
        RtlFillMemoryWithUlong (
            ptr, // ptr
            rowsz, // sz
            nativecolor, // ulong
        )

        row += 1
        ptr += mod
    END
END

FN KVDrawEmptyRectangle (
    IN nativecolor : UWORD,
    IN x : UWORD,
    IN y : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    gw := HALConsoleWidthPix

    mod := gw * 4

    kptr := FBAddr + (y * gw * 4 + x * 4)

    rowsz := w * 4

    // top edge
    RtlFillMemoryWithUlong (
        kptr, // ptr
        rowsz, // sz
        nativecolor, // ulong
    )

    IF h > 1 THEN
        bptr := kptr + (h - 1) * gw * 4

        // bottom edge
        RtlFillMemoryWithUlong (
            bptr, // ptr
            rowsz, // sz
            nativecolor, // ulong
        )
    END

    ptr := kptr

    hk := h

    // left edge
    WHILE hk DO
        ptr^ = nativecolor

        hk -= 1
        ptr += mod
    END

    IF w > 1 THEN
        ptr = kptr + (w - 1) * 4

        hk = h

        // right edge
        WHILE hk DO
            ptr^ = nativecolor

            ptr += mod
            hk -= 1
        END
    END
END

// mountains of redundant functions for various bit blit ops

FN KVBlitBitsFastFG (
    IN fg : UWORD,
    IN ptr : ^UBYTE,
    IN dest : ^VOID,
    IN mod : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    destp := CAST dest TO ^ULONG

    j : UWORD
    byte : UWORD
    left : UWORD

    WHILE h DO
        left = w >> 3
        WHILE left DO
            byte = ptr^

            IF byte THEN
                IF byte & 128 THEN
                    destp[7] = fg
                END

                IF byte & 64 THEN
                    destp[6] = fg
                END

                IF byte & 32 THEN
                    destp[5] = fg
                END

                IF byte & 16 THEN
                    destp[4] = fg
                END

                IF byte & 8 THEN
                    destp[3] = fg
                END

                IF byte & 4 THEN
                    destp[2] = fg
                END

                IF byte & 2 THEN
                    destp[1] = fg
                END

                IF byte & 1 THEN
                    destp[0] = fg
                END
            END

            destp += 32
            left -= 1
            ptr += 1
        END

        left = w & 7
        IF left THEN
            byte = ptr^
            ptr += 1
            j = 1

            WHILE left DO
                IF byte & j THEN
                    destp[0] = fg
                END

                destp += 4
                j <<= 1
                left -= 1
            END
        END

        destp += mod
        h -= 1
    END
END

FN KVBlitBitsFastBG (
    IN bg : UWORD,
    IN ptr : ^UBYTE,
    IN dest : ^VOID,
    IN mod : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    destp := CAST dest TO ^ULONG

    j : UWORD
    byte : UWORD
    left : UWORD

    WHILE h DO
        left = w >> 3
        WHILE left DO
            byte = ptr^

            IF NOT byte THEN
                destp[0] = bg
                destp[1] = bg
                destp[2] = bg
                destp[3] = bg
                destp[4] = bg
                destp[5] = bg
                destp[6] = bg
                destp[7] = bg
            ELSE
                IF NOT (byte & 128) THEN
                    destp[7] = bg
                END

                IF NOT (byte & 64) THEN
                    destp[6] = bg
                END

                IF NOT (byte & 32) THEN
                    destp[5] = bg
                END

                IF NOT (byte & 16) THEN
                    destp[4] = bg
                END

                IF NOT (byte & 8) THEN
                    destp[3] = bg
                END

                IF NOT (byte & 4) THEN
                    destp[2] = bg
                END

                IF NOT (byte & 2) THEN
                    destp[1] = bg
                END

                IF NOT (byte & 1) THEN
                    destp[0] = bg
                END
            END

            destp += 32
            left -= 1
            ptr += 1
        END

        left = w & 7
        IF left THEN
            byte = ptr^
            ptr += 1
            j = 1

            WHILE left DO
                IF NOT (byte & j) THEN
                    destp[0] = bg
                END

                destp += 4
                j <<= 1
                left -= 1
            END
        END

        destp += mod
        h -= 1
    END
END

FN KVBlitBitsFastFGBG (
    IN fg : UWORD,
    IN bg : UWORD,
    IN ptr : ^UBYTE,
    IN dest : ^VOID,
    IN mod : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    destp := CAST dest TO ^ULONG

    j : UWORD
    byte : UWORD
    left : UWORD

    WHILE h DO
        left = w >> 3
        WHILE left DO
            byte = ptr^

            IF NOT byte THEN
                destp[0] = bg
                destp[1] = bg
                destp[2] = bg
                destp[3] = bg
                destp[4] = bg
                destp[5] = bg
                destp[6] = bg
                destp[7] = bg
            ELSE
                IF byte & 128 THEN
                    destp[7] = fg
                ELSE
                    destp[7] = bg
                END

                IF byte & 64 THEN
                    destp[6] = fg
                ELSE
                    destp[6] = bg
                END

                IF byte & 32 THEN
                    destp[5] = fg
                ELSE
                    destp[5] = bg
                END

                IF byte & 16 THEN
                    destp[4] = fg
                ELSE
                    destp[4] = bg
                END

                IF byte & 8 THEN
                    destp[3] = fg
                ELSE
                    destp[3] = bg
                END

                IF byte & 4 THEN
                    destp[2] = fg
                ELSE
                    destp[2] = bg
                END

                IF byte & 2 THEN
                    destp[1] = fg
                ELSE
                    destp[1] = bg
                END

                IF byte & 1 THEN
                    destp[0] = fg
                ELSE
                    destp[0] = bg
                END
            END

            destp += 32
            left -= 1
            ptr += 1
        END

        left = w & 7
        IF left THEN
            byte = ptr^
            ptr += 1
            j = 1

            WHILE left DO
                IF byte & j THEN
                    destp[0] = fg
                ELSE
                    destp[0] = bg
                END

                destp += 4
                j <<= 1
                left -= 1
            END
        END

        destp += mod
        h -= 1
    END
END

// reversed ones

FN KVBlitBitsFastBackwardsFG (
    IN fg : UWORD,
    IN ptr : ^UBYTE,
    IN dest : ^VOID,
    IN mod : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    destp := CAST dest TO ^ULONG

    j : UWORD
    byte : UWORD
    left : UWORD

    WHILE h DO
        left = w >> 3
        WHILE left DO
            byte = ptr^

            IF byte THEN
                IF byte & 128 THEN
                    destp[0] = fg
                END

                IF byte & 64 THEN
                    destp[1] = fg
                END

                IF byte & 32 THEN
                    destp[2] = fg
                END

                IF byte & 16 THEN
                    destp[3] = fg
                END

                IF byte & 8 THEN
                    destp[4] = fg
                END

                IF byte & 4 THEN
                    destp[5] = fg
                END

                IF byte & 2 THEN
                    destp[6] = fg
                END

                IF byte & 1 THEN
                    destp[7] = fg
                END
            END

            destp += 32
            left -= 1
            ptr += 1
        END

        left = w & 7
        IF left THEN
            byte = ptr^
            ptr += 1
            
            IF w >> 3 THEN
                j = 128
            ELSE
                j = 1 << left
            END

            WHILE left DO
                IF byte & j THEN
                    destp[0] = fg
                END

                destp += 4
                j >>= 1
                left -= 1
            END
        END

        destp += mod
        h -= 1
    END
END

FN KVBlitBitsFastBackwardsBG (
    IN bg : UWORD,
    IN ptr : ^UBYTE,
    IN dest : ^VOID,
    IN mod : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    destp := CAST dest TO ^ULONG

    j : UWORD
    byte : UWORD
    left : UWORD

    WHILE h DO
        left = w >> 3
        WHILE left DO
            byte = ptr^

            IF NOT byte THEN
                destp[0] = bg
                destp[1] = bg
                destp[2] = bg
                destp[3] = bg
                destp[4] = bg
                destp[5] = bg
                destp[6] = bg
                destp[7] = bg
            ELSE
                IF NOT (byte & 128) THEN
                    destp[0] = bg
                END

                IF NOT (byte & 64) THEN
                    destp[1] = bg
                END

                IF NOT (byte & 32) THEN
                    destp[2] = bg
                END

                IF NOT (byte & 16) THEN
                    destp[3] = bg
                END

                IF NOT (byte & 8) THEN
                    destp[4] = bg
                END

                IF NOT (byte & 4) THEN
                    destp[5] = bg
                END

                IF NOT (byte & 2) THEN
                    destp[6] = bg
                END

                IF NOT (byte & 1) THEN
                    destp[7] = bg
                END
            END

            destp += 32
            left -= 1
            ptr += 1
        END

        left = w & 7
        IF left THEN
            byte = ptr^
            ptr += 1
            
            IF w >> 3 THEN
                j = 128
            ELSE
                j = 1 << left
            END

            WHILE left DO
                IF NOT (byte & j) THEN
                    destp[0] = bg
                END

                destp += 4
                j >>= 1
                left -= 1
            END
        END

        destp += mod
        h -= 1
    END
END

FN KVBlitBitsFastBackwardsFGBG (
    IN fg : UWORD,
    IN bg : UWORD,
    IN ptr : ^UBYTE,
    IN dest : ^VOID,
    IN mod : UWORD,
    IN w : UWORD,
    IN h : UWORD,
)

    destp := CAST dest TO ^ULONG

    j : UWORD
    byte : UWORD
    left : UWORD

    WHILE h DO
        left = w >> 3
        WHILE left DO
            byte = ptr^

            IF NOT byte THEN
                destp[0] = bg
                destp[1] = bg
                destp[2] = bg
                destp[3] = bg
                destp[4] = bg
                destp[5] = bg
                destp[6] = bg
                destp[7] = bg
            ELSE
                IF byte & 128 THEN
                    destp[0] = fg
                ELSE
                    destp[0] = bg
                END

                IF byte & 64 THEN
                    destp[1] = fg
                ELSE
                    destp[1] = bg
                END

                IF byte & 32 THEN
                    destp[2] = fg
                ELSE
                    destp[2] = bg
                END

                IF byte & 16 THEN
                    destp[3] = fg
                ELSE
                    destp[3] = bg
                END

                IF byte & 8 THEN
                    destp[4] = fg
                ELSE
                    destp[4] = bg
                END

                IF byte & 4 THEN
                    destp[5] = fg
                ELSE
                    destp[5] = bg
                END

                IF byte & 2 THEN
                    destp[6] = fg
                ELSE
                    destp[6] = bg
                END

                IF byte & 1 THEN
                    destp[7] = fg
                ELSE
                    destp[7] = bg
                END
            END

            destp += 32
            left -= 1
            ptr += 1
        END

        left = w & 7
        IF left THEN
            byte = ptr^
            ptr += 1
            
            IF w >> 3 THEN
                j = 128
            ELSE
                j = 1 << left
            END

            WHILE left DO
                IF byte & j THEN
                    destp[0] = fg
                ELSE
                    destp[0] = bg
                END

                destp += 4
                j >>= 1
                left -= 1
            END
        END

        destp += mod
        h -= 1
    END
END

FN KVDrawCharacter (
    IN char : UWORD,
    IN nativefg : UWORD,
    IN nativebg : UWORD,
    IN x : UWORD,
    IN y : UWORD,
    IN font : ^HCFHeader,
)

    gw := HALConsoleWidthPix

    w := font^.Width

    h := font^.Height

    dest := FBAddr + (y * gw * 4 + x * 4)

    mod := (gw - w) * 4

    bmp : ^VOID = font + SIZEOF HCFHeader + ((w + 7) >> 3) * h * char

    bitd := NOT (font^.Flags & HCFFLAG_REVERSE)

    IF nativefg == -1 THEN
        IF nativebg == -1 THEN
            LEAVE
        END

        IF bitd THEN
            KVBlitBitsFastBackwardsBG (
                nativebg, // bg
                bmp, // bmp
                dest, // dest
                mod, // mod
                w, // w
                h, // h
            )
        ELSE
            KVBlitBitsFastBG (
                nativebg, // bg
                bmp, // bmp
                dest, // dest
                mod, // mod
                w, // w
                h, // h
            )
        END
    ELSEIF nativebg == -1 THEN
        IF bitd THEN
            KVBlitBitsFastBackwardsFG (
                nativefg, // fg
                bmp, // bmp
                dest, // dest
                mod, // mod
                w, // w
                h, // h
            )
        ELSE
            KVBlitBitsFastFG (
                nativefg, // fg
                bmp, // bmp
                dest, // dest
                mod, // mod
                w, // w
                h, // h
            )
        END
    ELSE
        IF bitd THEN
            KVBlitBitsFastBackwardsFGBG (
                nativefg, // fg
                nativebg, // bg
                bmp, // bmp
                dest, // dest
                mod, // mod
                w, // w
                h, // h
            )
        ELSE
            KVBlitBitsFastFGBG (
                nativefg, // fg
                nativebg, // bg
                bmp, // bmp
                dest, // dest
                mod, // mod
                w, // w
                h, // h
            )
        END
    END
END